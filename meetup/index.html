<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css">
    <title>Word Cards</title>
</head>

<body>
    <div style="height:100px"></div>


    <div style="display: flex;justify-content: center; align-items: center;">
        <a style="margin: 0 auto;" href="../index.html" class="lesson_button">
            На главную
        </a>
    </div>

    <div style="height:100px"></div>


    <div class="cards-container">
        <div style="height:100px"></div>
    </div>



    <script>
        const words = [
            {
                "arabic": `The topic of the presentation is golang scheduler. `,
                "id": 0,
                "russian": `intro`,
            },
            {
                "arabic": `This presentation will cover key components of the Go Scheduler, including goroutines, OS threads, the roles of kernel space and user space, Sysmon, and the Netpoller. `,
                "id": 0,
                "russian": `table of contents`,
            },
            {
                "arabic": `The Go scheduler is a core component of the Go runtime, responsible for managing the execution of goroutines on operating system (OS) threads. It's a key reason why Go is so effective for concurrent programming, as it handles the complexities of scheduling for you.`,
                "id": 0,
                "russian": `scheduler is`,
            },
            {
                "arabic": `goroutines are so called lightweight threads. They called lightweight because they are much more memory efficient than traditional OS threads. A goroutine typically starts with a small stack size (a few kilobytes) that can grow and shrink as needed, whereas OS threads usually have a fixed stack size (often around 1 MB). This allows you to create thousands or even millions of goroutines in a single application without exhausting system resources. Also, goroutines run in user space, unlike OS threads that run in kernel space, and concurrent operations in kernel space are much more expensive than in user space.`,
                "id": 0,
                "russian": `goroutines are`,
            },
            {
                "arabic": `are fundamental concepts in the architecture of modern operating systems (OS) that help ensure the stability and security of the computer. 
                The Kernel Space is the privileged region of memory where the Operating System Kernel executes. It has full access to all hardware and system resources, including memory management, process scheduling, and hardware communication. Code running in kernel space operates with high privileges, allowing it to perform critical tasks that are essential for the functioning of the OS. However, this also means that any bugs or vulnerabilities in kernel space code can lead to system crashes or security breaches.
                User Space, on the other hand, is the memory region where user applications and processes run. Code executing in user space has limited access to system resources and cannot directly interact with hardware or perform privileged operations. This separation helps protect the OS from accidental or malicious interference by user applications, as any faults in user space code will not compromise the overall stability of the system. When a user application needs to perform a task that requires higher privileges (like accessing hardware), it must make a system call to transition from user space to kernel space.
                The core resource for program execution is processor cores.

Cores are scarce, but they have a lot of work, which is why the concept of threads is introduced: threads execute on cores.

The OS scheduler manages threads and optimizes their use to ensure that the cores aren't idle.

OS threads are large and 'scary'—not because they're poorly designed, but because the OS level has its own constraints and operational specifics, meaning we have few threads available to us.

Since there are few threads, but a lot of work inside our program, the concept of goroutines is introduced: goroutines execute on threads.

The Go scheduler manages goroutines and optimizes their use to maximize the effective utilization of threads—creating as few of them as possible and preventing them from becoming idle.
                `,
                "id": 1,
                "russian": `Kernel Space and User Space`,
            },
            {
                "arabic": `There is an entity called Processor. A Processor is an abstraction that represents a logical CPU core. It is not a physical core but rather a context that allows the Go scheduler to manage the execution of goroutines on OS threads. Each Processor is attached to an OS thread, and we can define the number of OS threads using the GOMAXPROCS function. Also each Processor has its own local queue of goroutines that are ready to execute. Goroutines have three key states: Runnable, Executing and Waiting. A Runnable goroutine is one that is ready to run but is not currently executing. An Executing goroutine is one that is currently running on an OS thread. A Waiting goroutine is one that is blocked, either waiting for I/O operations to complete or for a synchronization primitive (like a mutex) to become available. The Go scheduler uses a work-stealing algorithm to balance the load across multiple Processors. If one Processor has a lot of Runnable goroutines while another is idle, the idle Processor can "steal" work from the busy one to ensure efficient CPU utilization.
                Also there are global queue of goroutines and Netpoller queue of goroutines. The global queue is used to store goroutines that are ready to run but cannot be assigned to a specific Processor because all Processors are busy. The Netpoller queue is used to manage goroutines that are waiting for network I/O operations to complete. The Netpoller is a special component of the Go runtime that efficiently monitors network connections and wakes up goroutines when data is available to read or write.
                If a goroutine performs a blocking operation (like waiting for I/O), its Processor will be detached from the OS thread and will be attached to another OS thread. This helps prevent idle threads and ensures that the available OS threads are used efficiently. And this goroutine will be placed in the Netpoller queue.
                So the algorithm of the scheduler is:
                1. First We check the Global queue once every 61 times, and if there are any Runnable goroutines there, we take them from it. So that goroutines that have been waiting for a long time in the global queue get a chance to run.
                2. Then We check the Local queue of the Processor for Runnable goroutines.
                3. Then If there are no Runnable goroutines in the Local queue, we try to steal a goroutine from another Processor's Local queue.
                4. Then If we can't find any Runnable goroutines in the Local queue or steal from another Processor, we check the Netpoller queue for any goroutines that are ready to run.
                Also there is a process called Sysmon that every 10 milliseconds checks the Netpoller queue for goroutines that are ready to run, checks for long-running goroutines that may be blocking the system, and performs other maintenance tasks to ensure the smooth operation of the Go scheduler.
                `,
                "id": 2,
                "russian": `So how the Scheduler works`,
            },
            {
                "arabic": `And that's it. If you have any questions, please ask.`,
                "id": 3,
                "russian": `ending`,
            },
            
        ];

        class Card {
            constructor(word) {
                this.word = word;
                this.displayedText = '';
                this.currentCharIndex = 0;
                this.currentWordIndex = 0;
                this.words = this.word.arabic.split(' ');
                this.cardElement = this.createCardElement();
            }

            createCardElement() {
                const card = document.createElement('div');
                card.className = 'card';

                const russianWord = document.createElement('div');
                russianWord.innerText = this.word.russian;
                card.appendChild(russianWord);

                const buttons = document.createElement('div');
                buttons.className = 'buttons';

                this.hideTextButton = this.createButton('Скрыть текст', this.hideText.bind(this));
                this.revealNextCharButton = this.createButton('Открыть одну букву', this.revealNextChar.bind(this));
                this.revealNextWordButton = this.createButton('Открыть слово', this.revealNextWord.bind(this));
                this.revealAllTextButton = this.createButton('Открыть всё', this.revealAllText.bind(this));

                buttons.appendChild(this.hideTextButton);
                buttons.appendChild(this.revealNextCharButton);
                buttons.appendChild(this.revealNextWordButton);
                buttons.appendChild(this.revealAllTextButton);

                card.appendChild(buttons);

                this.arabicWordElement = document.createElement('div');
                this.arabicWordElement.className = 'translation';
                this.arabicWordElement.innerText = this.displayedText;
                card.appendChild(this.arabicWordElement);

                this.updateButtonStates();
                return card;
            }

            createButton(text, onClick) {
                const button = document.createElement('button');
                button.innerText = text;
                button.onclick = onClick;
                return button;
            }

            hideText() {
                this.displayedText = '';
                this.currentCharIndex = 0;
                this.currentWordIndex = 0;
                this.updateTranslation();
                this.updateButtonStates();
            }

            revealNextChar() {
                if (this.currentCharIndex < this.word.arabic.length) {
                    this.displayedText = this.word.arabic.substring(0, this.currentCharIndex + 1);
                    this.currentCharIndex++;
                    if (this.displayedText.endsWith(' ')) {
                        this.currentWordIndex++;
                    }
                    if (this.currentCharIndex === this.word.arabic.length) {
                        this.displayedText = this.word.arabic;
                        this.currentCharIndex = this.word.arabic.length;
                        this.currentWordIndex = this.words.length;
                    }
                    this.updateTranslation();
                    this.updateButtonStates();
                }
            }

            revealNextWord() {
                if (this.currentWordIndex < this.words.length) {
                    this.displayedText = this.words.slice(0, this.currentWordIndex + 1).join(' ') + ' ';
                    this.currentCharIndex = this.displayedText.length;
                    this.currentWordIndex++;
                    this.updateTranslation();
                    this.updateButtonStates();
                }
            }

            revealAllText() {
                this.displayedText = this.word.arabic;
                this.currentCharIndex = this.word.arabic.length;
                this.currentWordIndex = this.words.length;
                this.updateTranslation();
                this.updateButtonStates();
            }

            updateTranslation() {
                this.arabicWordElement.innerText = this.displayedText;
            }

            updateButtonStates() {
                this.hideTextButton.disabled = !this.displayedText;
                this.revealNextCharButton.disabled = this.currentCharIndex >= this.word.arabic.length;
                this.revealNextWordButton.disabled = this.currentWordIndex >= this.words.length;
                this.revealAllTextButton.disabled = this.currentCharIndex >= this.word.arabic.length;
            }

            appendTo(container) {
                container.appendChild(this.cardElement);
            }
        }

        const cardsContainer = document.querySelector('.cards-container');
        words.forEach(word => {
            const divider = document.createElement('hr');
            divider.style.border = 'none';
            divider.style.height = '1px';
            divider.style.backgroundColor = '#909090';
            divider.style.margin = '20px 0';

            cardsContainer.appendChild(divider);


            const card = new Card(word);
            card.appendTo(cardsContainer);

            const sizedBox = document.createElement('div');
            sizedBox.style.height = '20px';
            cardsContainer.appendChild(sizedBox);
        });
        const sizedBox = document.createElement('div');
        sizedBox.style.height = '400px';
        cardsContainer.appendChild(sizedBox);
    </script>
</body>

</html>