<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../style.css">
    <title>Word Cards</title>
</head>

<body>
    <div style="height:100px"></div>


    <div style="display: flex;justify-content: center; align-items: center;">
        <a style="margin: 0 auto;" href="../index.html" class="lesson_button">
            На главную
        </a>
    </div>

    <div style="height:100px"></div>


    <div class="cards-container">
        <div style="height:100px"></div>
    </div>



    <script>
        const words = [{
                "arabic": `The Go scheduler is a core component of the Go runtime, responsible for managing the execution of goroutines on operating system (OS) threads. It's a key reason why Go is so effective for concurrent programming, as it handles the complexities of scheduling for you.`,
                "id": 0,
                "russian": `scheduler is`,
            },
            {
                "arabic": `The scheduler is often described using the G-M-P model, which represents the three main entities it manages:`,
                "id": 0,
                "russian": `The G-M-P Model`,
            },
            {
                "arabic": `This is the unit of work in Go. Goroutines are lightweight, user-space threads that start with a very small stack (as little as 2KB) and can grow and shrink dynamically. You create them with the go keyword. A Go program can easily have thousands or even millions of goroutines running concurrently.`,
                "id": 1,
                "russian": `G (Goroutine):`,
            },
            {
                "arabic": `This represents an OS thread. These are the "workers" that execute Go code. The Go runtime creates and manages a pool of M's.`,
                "id": 2,
                "russian": `M (Machine):`,
            },
            {
                "arabic": `This is a logical processor that acts as a context for running a goroutine. It's the "link" between the Gs and the Ms. Each P has a local queue of goroutines that are ready to run. The number of P's is determined by the value of GOMAXPROCS, which defaults to the number of CPU cores on your machine. An M must be associated with a P to execute Go code.`,
                "id": 3,
                "russian": `P (Processor):`,
            },
            {
                "arabic": `The scheduler multiplexes a large number of goroutines (G) onto a smaller number of OS threads (M) using a fixed number of logical processors (P). The process works like this: A P has a local run queue of goroutines. An M is assigned to a P. The M pulls a goroutine from the P's local queue and executes it. If a goroutine needs to do a blocking system call (like reading from a file), the M detaches from the P. The P can then pick up a new M (if one is available) and continue running other goroutines from its queue. Once the system call is finished, the goroutine is placed back into a runnable state to be scheduled again. If a P's local queue becomes empty, it will first check a global queue for work. If that's also empty, it will use a technique called work stealing, where it "steals" goroutines from the local queue of another busy P to keep itself productive.`,
                "id": 3,
                "russian": `How it Works`,
            },
            
        ];

        class Card {
            constructor(word) {
                this.word = word;
                this.displayedText = '';
                this.currentCharIndex = 0;
                this.currentWordIndex = 0;
                this.words = this.word.arabic.split(' ');
                this.cardElement = this.createCardElement();
            }

            createCardElement() {
                const card = document.createElement('div');
                card.className = 'card';

                const russianWord = document.createElement('div');
                russianWord.innerText = this.word.russian;
                card.appendChild(russianWord);

                const buttons = document.createElement('div');
                buttons.className = 'buttons';

                this.hideTextButton = this.createButton('Скрыть текст', this.hideText.bind(this));
                this.revealNextCharButton = this.createButton('Открыть одну букву', this.revealNextChar.bind(this));
                this.revealNextWordButton = this.createButton('Открыть слово', this.revealNextWord.bind(this));
                this.revealAllTextButton = this.createButton('Открыть всё', this.revealAllText.bind(this));

                buttons.appendChild(this.hideTextButton);
                buttons.appendChild(this.revealNextCharButton);
                buttons.appendChild(this.revealNextWordButton);
                buttons.appendChild(this.revealAllTextButton);

                card.appendChild(buttons);

                this.arabicWordElement = document.createElement('div');
                this.arabicWordElement.className = 'translation';
                this.arabicWordElement.innerText = this.displayedText;
                card.appendChild(this.arabicWordElement);

                this.updateButtonStates();
                return card;
            }

            createButton(text, onClick) {
                const button = document.createElement('button');
                button.innerText = text;
                button.onclick = onClick;
                return button;
            }

            hideText() {
                this.displayedText = '';
                this.currentCharIndex = 0;
                this.currentWordIndex = 0;
                this.updateTranslation();
                this.updateButtonStates();
            }

            revealNextChar() {
                if (this.currentCharIndex < this.word.arabic.length) {
                    this.displayedText = this.word.arabic.substring(0, this.currentCharIndex + 1);
                    this.currentCharIndex++;
                    if (this.displayedText.endsWith(' ')) {
                        this.currentWordIndex++;
                    }
                    if (this.currentCharIndex === this.word.arabic.length) {
                        this.displayedText = this.word.arabic;
                        this.currentCharIndex = this.word.arabic.length;
                        this.currentWordIndex = this.words.length;
                    }
                    this.updateTranslation();
                    this.updateButtonStates();
                }
            }

            revealNextWord() {
                if (this.currentWordIndex < this.words.length) {
                    this.displayedText = this.words.slice(0, this.currentWordIndex + 1).join(' ') + ' ';
                    this.currentCharIndex = this.displayedText.length;
                    this.currentWordIndex++;
                    this.updateTranslation();
                    this.updateButtonStates();
                }
            }

            revealAllText() {
                this.displayedText = this.word.arabic;
                this.currentCharIndex = this.word.arabic.length;
                this.currentWordIndex = this.words.length;
                this.updateTranslation();
                this.updateButtonStates();
            }

            updateTranslation() {
                this.arabicWordElement.innerText = this.displayedText;
            }

            updateButtonStates() {
                this.hideTextButton.disabled = !this.displayedText;
                this.revealNextCharButton.disabled = this.currentCharIndex >= this.word.arabic.length;
                this.revealNextWordButton.disabled = this.currentWordIndex >= this.words.length;
                this.revealAllTextButton.disabled = this.currentCharIndex >= this.word.arabic.length;
            }

            appendTo(container) {
                container.appendChild(this.cardElement);
            }
        }

        const cardsContainer = document.querySelector('.cards-container');
        words.forEach(word => {
            const divider = document.createElement('hr');
            divider.style.border = 'none';
            divider.style.height = '1px';
            divider.style.backgroundColor = '#909090';
            divider.style.margin = '20px 0';

            cardsContainer.appendChild(divider);


            const card = new Card(word);
            card.appendTo(cardsContainer);

            const sizedBox = document.createElement('div');
            sizedBox.style.height = '20px';
            cardsContainer.appendChild(sizedBox);
        });
        const sizedBox = document.createElement('div');
        sizedBox.style.height = '400px';
        cardsContainer.appendChild(sizedBox);
    </script>
</body>

</html>